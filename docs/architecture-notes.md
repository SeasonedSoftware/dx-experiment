# Notes on architecture decisions

## Current framework design

The project is split into 3 main pieces, reflected by the root directory structure.
These parts are defined by where the code is executed and, therefore, where the state is managed in the client-server model.

* ui - code that runs in the browser.
* domain-logic - code that is shared between client and server. These are the domain actions (or events depending on terminology) that will always run on the server but have proxy functions to be called in the browser.
* jobs - code that runs only on server, either on a clock or upon receiving asynchronous messages.

Besides the section *Definitions* from the [README](../README.md) the framework is agnostic in relation to how the application and its database are modelled. The developer should be able to chose something closer to an event sourced application with immutable data or something more along the lines of mutable entities.

Our main goal is to remove the friction of having to think in terms of HTTP (which is an implementation detail in most systems) or any other protocol and allow the developer to focus on writing the domain logic, which is usually the main concern of the software development process.

Another project goal is to keep interfaces easy to design and enforced on the type level. This should help the developer to code against well defined interfaces reducing bugs and cognitive burden.

### Guiding Principles

* The [zen of python](https://www.python.org/dev/peps/pep-0020/) is awesome, start there.
* We care about modelling concepts from the real world, everything else is accidental complexity.
* Chose vertical over horizontal scaling as much as possible.
* The best code is the one you don't need to write.
* But if it's written somewhere, it's usually better inside your repository.
* The second best code is the one it's used only for type-checking.
* The best way to prepare software for the future is coding for the present.
* The documentation is the part of your system that runs in your fellow humans' mushy computers.
* If you can code something that will make the documentation shorter, it's usually a good idea.
* Running software is a living organism, code is its fossil, we should focus on the first.

Bellow there are some past notes that give some context on how we got to this design. Consider it a map of the paths not taken.

## The Croods model

```
<Fetch> : Concrete type in the backend -> Derive an abstract type in the frontend.
```

The idea in the current croods implementation is that the consumer of the API does not care about specifics of the types it consumes. So in a very *duck typing* way it cares only about the attributes being used, but without any type-casting or run-time assertions.

## Proposed Alternative A

In order to increase safety, one of the proposed changes is that we reverse the way endpoint produces and consumers are defined so that it would look like:

```
type Event = (description: String) => Fetch<Todo|Error> : Abstract type -> Developer inform additional details to derive concrete type and implementation for both frontend and backend
```

Idealy this would be generated by the compiler using only data from the type system (using [Haskell's servant as inspiration](https://docs.servant.dev/en/stable/tutorial/Server.html)). The code would look like:

```typescript
type FetchTodo = (description: String) => Fetch<Todo|Error>

const fetchTodo : FetchTodo = makeHttpClientEndpoint('/todos')
```

The type would be used with some implementation to derive a fully funcioning API client (the server could use a similar principle). The issue with the approach above is that it seems very challenging in terms of implementation using TypeScript's type system.

Therefore a more traditional approach where we read the type level information in another program that will act as a sort of macro or scaffolding to generate and maintain the necessary boilerplate reducing the need for deep type system hacks.

One example of how this could look like is seen bellow.

```typescript
type Events =
    { create: (description: String) => Send<Todo|Error>
    , check: (description: String, checkedAt: Timestamp) => Send<Todo|Error>
    , fetch: (since: Timestamp, until: Timestamp) => Fetch<[Todo]|Error>
    }


const client = makeHttpClient('./events.js', {
    // returns a new state and generate side effects
    create: (createPayload, prevState) => http.post(createPayload.description)
}) // Implement full protocol on the client side

const server = makeHttpServer('./events.js', {
    // returns an API response and generate side effects
    create: (createPayload, prevState) => database.create(description: createPayload.description, checkedAt: null)
}) // Implement full protocol on the client side
```
## Proposed Alternative B

The second proposal requires less boilerplate since the interfaces would be defined by the database structure (similar to current [croods-rails](https://github.com/SeasonedSoftware/croods-rails) model).

The workflow looks like:
```
Define database schema -> Derive concrete API assuming append only semantics

The developer would add reducers in the form of views to complement the read portion API.
```

The generated system would be 100% event sourced. All API endpoints that persist data would only create events that would be handled asyncronously in the backend.

One example of a simple TODO application could be defined as the example bellow:

### DB Schema

#### Tables
CreateTodo (description: String)
CheckTodo (description: String, checkedAt: Timestamp)

#### Views (aggregates)
Todos (description: String, checkedAt: Timestamp)
