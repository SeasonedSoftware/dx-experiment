# Paths not taken

The purpose of this document is to keep track of alternate designs that we decided to abandon.
The importance here is to avoid "walking in circles" and go back to design choices that were already explored.

## The Croods model

```
<Fetch> : Concrete type in the backend -> Derive an abstract type in the frontend.
```

The idea in the current croods implementation is that the consumer of the API does not care about specifics of the types it consumes. So in a very *duck typing* way it cares only about the attributes being used, but without any type-casting or run-time assertions.

### Why it was abandoned

This model gives little support for the developer when using the API on the browser since the typing is not bound to the server side code. So projects can have drift between the server and client thus breaking the API contract. It also exposes a lot of details about the HTTP protocol in the form of the `REST` model.

## Proposed Alternative A

In order to increase safety, one of the proposed changes is that we reverse the way endpoint produces and consumers are defined so that it would look like:

```
type Event = (description: String) => Fetch<Todo|Error> : Abstract type -> Developer inform additional details to derive concrete type and implementation for both frontend and backend
```

Idealy this would be generated by the compiler using only data from the type system (using [Haskell's servant as inspiration](https://docs.servant.dev/en/stable/tutorial/Server.html)). The code would look like:

```typescript
type FetchTodo = (description: String) => Fetch<Todo|Error>

const fetchTodo : FetchTodo = makeHttpClientEndpoint('/todos')
```

The type would be used with some implementation to derive a fully funcioning API client (the server could use a similar principle). The issue with the approach above is that it seems very challenging in terms of implementation using TypeScript's type system.

Therefore a more traditional approach where we read the type level information in another program that will act as a sort of macro or scaffolding to generate and maintain the necessary boilerplate reducing the need for deep type system hacks.

One example of how this could look like is seen bellow.

```typescript
type Events =
    { create: (description: String) => Send<Todo|Error>
    , check: (description: String, checkedAt: Timestamp) => Send<Todo|Error>
    , fetch: (since: Timestamp, until: Timestamp) => Fetch<[Todo]|Error>
    }


const client = makeHttpClient('./events.js', {
    // returns a new state and generate side effects
    create: (createPayload, prevState) => http.post(createPayload.description)
}) // Implement full protocol on the client side

const server = makeHttpServer('./events.js', {
    // returns an API response and generate side effects
    create: (createPayload, prevState) => database.create(description: createPayload.description, checkedAt: null)
}) // Implement full protocol on the client side
```

### Why it was abandoned

This was not entirely abandoned, our current approach evolved from this path. The main difference between the current approach and the one described here is that we doubled down on the abstraction based on `actions` and hid the HTTP and REST api api a bit further. The reason why is that HTTP and REST should be implementation details and we really don't want developers to spend brain cycles on the mechanics of how the API is implemented (as opposed to how the API is defined).


## Proposed Alternative B

The second proposal requires less boilerplate since the interfaces would be defined by the database structure (similar to current [croods-rails](https://github.com/SeasonedSoftware/croods-rails) model).

The workflow looks like:
```
Define database schema -> Derive concrete API assuming append only semantics

The developer would add reducers in the form of views to complement the read portion API.
```

The generated system would be 100% event sourced. All API endpoints that persist data would only create events that would be handled asyncronously in the backend.

One example of a simple TODO application could be defined as the example bellow:

### DB Schema

#### Tables
CreateTodo (description: String)
CheckTodo (description: String, checkedAt: Timestamp)

#### Views (aggregates)
Todos (description: String, checkedAt: Timestamp)

### Why it was abandoned

We thought that imposing the data architecture was beyond the scope of the framework. A simpler design would allow this sort of system to be developed without imposing the decision on developers.